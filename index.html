<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Instance Chronometer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Space+Mono:wght@700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }

        /* Custom utility for responsive grid */
        .grid-auto-fit {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        /* Time display font */
        .time-display {
            font-family: 'Space Mono', monospace;
        }

        /* Custom button styling */
        .btn-base {
            padding: 0.6rem 1rem;
            font-weight: 600;
            border-radius: 0.5rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8 bg-gray-50">

    <div class="max-w-6xl mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-extrabold text-gray-900 mb-2">
                Multi-Instance Chrono
            </h1>
            <p class="text-gray-600">
                Manage multiple stopwatches and timers simultaneously using vanilla JS.
            </p>
        </header>

        <!-- New Instance Creator -->
        <div class="bg-white p-5 md:p-8 rounded-2xl shadow-xl mb-10 border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-900 mb-4">
                Add New Instance
            </h2>
            
            <div class="flex flex-col md:flex-row gap-4 mb-6">
                 <!-- Label Input -->
                <input
                    id="labelInput"
                    type="text"
                    placeholder="Enter a label (e.g., 'Bake Bread')"
                    class="flex-grow p-3 rounded-lg border border-gray-300 focus:ring-blue-500 focus:border-blue-500"
                    maxlength="30"
                />
                 <!-- Timer Duration Input -->
                <div class="flex-grow">
                    <input
                        id="timerInput"
                        type="text"
                        value="0:5:0"
                        placeholder="Timer Duration (H:M:S, e.g., 0:5:0)"
                        class="w-full p-3 rounded-lg border border-gray-300 focus:ring-pink-500 focus:border-pink-500"
                    />
                </div>
            </div>

            <div class="flex flex-col sm:flex-row gap-4">
                <button
                    id="addStopwatchBtn"
                    class="flex-1 btn-base text-white bg-cyan-600 hover:bg-cyan-700 shadow-md shadow-cyan-500/50 transform hover:-translate-y-0.5"
                >
                    Add Stopwatch ⏱️
                </button>
                <button
                    id="addTimerBtn"
                    class="flex-1 btn-base text-white bg-pink-600 hover:bg-pink-700 shadow-md shadow-pink-500/50 transform hover:-translate-y-0.5"
                >
                    Add Timer ⏳
                </button>
            </div>
        </div>

        <!-- Instances Display Grid -->
        <div id="instancesContainer" class="grid-auto-fit">
            <!-- Timer instances will be rendered here -->
            <div class="text-center p-10 bg-white/50 rounded-xl col-span-full" id="emptyState">
                <p class="text-gray-500 text-lg">
                    No timers or stopwatches active. Add one above!
                </p>
            </div>
        </div>
    </div>

    <script>
        // Global state array to hold all timer/stopwatch objects
        let instances = [];
        let nextId = 1;

        // --- DOM Elements ---
        const instancesContainer = document.getElementById('instancesContainer');
        const emptyState = document.getElementById('emptyState');
        const timerInput = document.getElementById('timerInput');
        const labelInput = document.getElementById('labelInput');
        const addStopwatchBtn = document.getElementById('addStopwatchBtn');
        const addTimerBtn = document.getElementById('addTimerBtn');

        // --- Utility Functions ---

        /**
         * Formats time from milliseconds into HH:MM:SS.ms string.
         * @param {number} ms - Time in milliseconds.
         * @returns {string} Formatted time string.
         */
        function formatTime(ms) {
            const totalMs = Math.max(0, ms);
            const totalSeconds = Math.floor(totalMs / 1000);
            const milliseconds = Math.floor((totalMs % 1000) / 10);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            const pad = (num, length = 2) => String(num).padStart(length, '0');

            if (hours > 0) {
                return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}.${pad(milliseconds)}`;
            }
            return `${pad(minutes)}:${pad(seconds)}.${pad(milliseconds)}`;
        }

        /**
         * Parses H:M:S string input into total milliseconds.
         * @param {string} input - Time string (e.g., "0:1:30").
         * @returns {number} Total milliseconds.
         */
        function parseDuration(input) {
            const parts = input.split(':').map(p => parseInt(p.trim()) || 0).reverse();
            let totalMs = 0;
            // seconds, minutes, hours
            if (parts[0]) totalMs += parts[0] * 1000;
            if (parts[1]) totalMs += parts[1] * 60 * 1000;
            if (parts[2]) totalMs += parts[2] * 60 * 60 * 1000;
            return Math.max(0, totalMs);
        }

        /**
         * Plays a simple alarm sound using the Web Audio API.
         */
        function playAlarmSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const oscillator = audioContext.createOscillator();
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(660, audioContext.currentTime);

                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                
                const duration = 1.0; 
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                oscillator.stop(audioContext.currentTime + duration);

                // Clean up the context
                setTimeout(() => audioContext.close().catch(() => {}), (duration + 0.1) * 1000);

            } catch (e) {
                console.warn("Could not play sound. User interaction needed to start AudioContext.", e);
            }
        }

        // --- Rendering Function ---

        /**
         * Renders all instances to the DOM.
         */
        function renderInstances() {
            instancesContainer.innerHTML = ''; // Clear existing content

            if (instances.length === 0) {
                emptyState.style.display = 'block';
                return;
            } else {
                emptyState.style.display = 'none';
            }

            instances.forEach(inst => {
                const isStopwatch = inst.type === 'stopwatch';
                
                // Determine card background based on state
                let bgColor = 'bg-white/50';
                if (inst.isRunning) {
                    bgColor = 'bg-emerald-500/20 shadow-lg shadow-emerald-500/30';
                } else if (inst.isFinished) {
                    bgColor = 'bg-red-500/20 shadow-lg shadow-red-500/30 ring-4 ring-red-500/50';
                } else if (inst.time > 0 && !inst.isRunning) {
                    bgColor = 'bg-blue-500/20 shadow-lg shadow-blue-500/30';
                }
                
                // Button styles and content
                const baseButtonStyle = 'px-3 py-1.5 text-sm font-semibold rounded-lg transition duration-200 shadow-md hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed';
                
                const controlButton = inst.isRunning ?
                    `<button data-action="pause" class="${baseButtonStyle} bg-yellow-600 text-white hover:bg-yellow-700">Pause</button>` :
                    `<button data-action="start" class="${baseButtonStyle} bg-emerald-600 text-white hover:bg-emerald-700" ${inst.isFinished && !isStopwatch ? 'disabled' : ''}>Start</button>`;
                
                // Status text
                let statusText;
                let statusColor;
                if (inst.isFinished) {
                    statusText = "TIME'S UP!";
                    statusColor = 'text-red-600 font-bold';
                } else if (inst.isRunning) {
                    statusText = "Running...";
                    statusColor = 'text-emerald-700';
                } else if (inst.time > 0) {
                    statusText = "Paused";
                    statusColor = 'text-blue-700';
                } else {
                    statusText = "Ready";
                    statusColor = 'text-gray-700';
                }

                const cardHTML = `
                    <div data-id="${inst.id}" class="p-4 md:p-6 rounded-2xl backdrop-blur-sm ${bgColor} border border-white/30 flex flex-col gap-4">
                        <!-- Header and Delete Button -->
                        <div class="flex justify-between items-center pb-2 border-b border-white/20">
                            <h3 class="text-xl font-bold text-gray-900 flex items-center gap-2">
                                <span class="p-2 rounded-full ${isStopwatch ? 'bg-cyan-500' : 'bg-pink-500'}">
                                    ${isStopwatch ? '⏱️' : '⏳'}
                                </span>
                                ${inst.label}
                            </h3>
                            <button 
                                data-action="delete"
                                class="text-gray-500 hover:text-red-500 transition-colors"
                                title="Delete Instance"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 pointer-events-none" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                </svg>
                            </button>
                        </div>

                        <!-- Time Display -->
                        <div class="time-display text-5xl md:text-6xl font-extrabold text-center text-gray-900 ${inst.isFinished ? 'text-red-600 animate-pulse' : ''}">
                            ${formatTime(inst.time)}
                        </div>
                        
                        <!-- Status Indicator -->
                        <div class="text-center text-sm font-medium h-4">
                            <span class="${statusColor}">${statusText}</span>
                        </div>

                        <!-- Controls -->
                        <div class="flex gap-3 justify-center pt-2 border-t border-white/20">
                            ${controlButton}
                            <button
                                data-action="reset"
                                class="${baseButtonStyle} bg-gray-300 text-gray-800 hover:bg-gray-400"
                            >
                                Reset
                            </button>
                        </div>
                    </div>
                `;
                instancesContainer.insertAdjacentHTML('beforeend', cardHTML);
            });
        }


        // --- Core Logic Loop ---

        function updateInstances() {
            const now = Date.now();
            let updated = false;

            instances = instances.map(inst => {
                if (!inst.isRunning) return inst;

                const elapsedTime = now - inst.lastUpdateTime;
                
                // Prevent huge jumps
                if (elapsedTime > 500) {
                    return { ...inst, lastUpdateTime: now }; 
                }

                updated = true;
                
                let newTime;
                let isRunningNew = true;
                let isFinishedNew = inst.isFinished;

                if (inst.type === 'stopwatch') {
                    // Stopwatch: time increases
                    newTime = inst.time + elapsedTime;
                } else {
                    // Timer: time decreases
                    newTime = inst.time - elapsedTime;

                    if (newTime <= 0) {
                        if (inst.isRunning && !inst.isFinished) {
                            // Timer just finished!
                            playAlarmSound();
                        }
                        newTime = 0;
                        isRunningNew = false;
                        isFinishedNew = true;
                    }
                }

                return { 
                    ...inst, 
                    time: newTime, 
                    isRunning: isRunningNew, 
                    isFinished: isFinishedNew,
                    lastUpdateTime: now
                };
            });

            if (updated) {
                renderInstances();
            }
        }

        // Start the core update loop (10ms for smooth UI)
        setInterval(updateInstances, 10); 


        // --- Event Handlers ---

        function addStopwatch() {
            const label = labelInput.value.trim() || `Stopwatch ${nextId}`;
            const newStopwatch = {
                id: nextId++,
                type: 'stopwatch',
                isRunning: false,
                time: 0,
                initialDuration: 0,
                label: label,
                isFinished: false,
                lastUpdateTime: Date.now(),
            };
            instances.push(newStopwatch);
            labelInput.value = '';
            renderInstances();
        }

        function addTimer() {
            const duration = parseDuration(timerInput.value);
            if (duration === 0) {
                // Use a custom message box instead of alert() if necessary, but console.warn is fine for simple input validation
                console.warn("Timer duration must be greater than zero.");
                return;
            }

            const label = labelInput.value.trim() || `Timer ${nextId}`;
            const newTimer = {
                id: nextId++,
                type: 'timer',
                isRunning: false,
                time: duration,
                initialDuration: duration,
                label: label,
                isFinished: false,
                lastUpdateTime: Date.now(),
            };
            instances.push(newTimer);
            labelInput.value = '';
            timerInput.value = '0:5:0'; 
            renderInstances();
        }

        function handleControl(id, action) {
            const index = instances.findIndex(inst => inst.id === id);
            if (index === -1) return;
            
            const inst = instances[index];
            const now = Date.now();

            switch (action) {
                case 'start':
                    if (inst.isRunning) return;
                    inst.isRunning = true;
                    inst.isFinished = false;
                    inst.lastUpdateTime = now;
                    break;
                case 'pause':
                    if (!inst.isRunning) return;
                    inst.isRunning = false;
                    break;
                case 'reset':
                    inst.isRunning = false;
                    inst.time = inst.type === 'stopwatch' ? 0 : inst.initialDuration;
                    inst.isFinished = false;
                    break;
                case 'delete':
                    instances.splice(index, 1);
                    break;
            }
            renderInstances();
        }

        // Event Listeners setup
        addStopwatchBtn.addEventListener('click', addStopwatch);
        addTimerBtn.addEventListener('click', addTimer);

        instancesContainer.addEventListener('click', (event) => {
            let target = event.target;

            // Find the closest button element with a data-action attribute
            while (target && target !== instancesContainer) {
                if (target.dataset.action) {
                    const action = target.dataset.action;
                    
                    // Find the parent timer card to get the ID
                    const card = target.closest('[data-id]');
                    if (card) {
                        const id = parseInt(card.dataset.id);
                        handleControl(id, action);
                    }
                    return;
                }
                target = target.parentNode;
            }
        });

        // Initial render to show the empty state
        window.onload = renderInstances;
    </script>
</body>
</html>
